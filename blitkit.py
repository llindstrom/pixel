import functools

class Blitter:
    def __init__(self, method, loop_indices):
        if len(loop_indices) != 2:
            raise ValueError("Only supports 2 dimensional arrays for now")
        self.method = method
        self.loop_indices = loop_indices

    def __call__(self, src_type, dst_type):
        return self.method(src_type, dst_type, self.loop_indices)

class BlitterFactory:
    """Base class"""

    def __init__(self, src_type, dst_type, loop_indices):
        self.src_type = src_type
        self.dst_type = dst_type
        self.loop_indices = loop_indices

    def __call__(self, fn):
        raise NotImplementedError("To be implemented in subclasses")

class C_Iterators(BlitterFactory):
    """Stub factory; indices are ignored"""

    def __call__(self, fn):
        """Stub function"""
        src_type = self.src_type
        dst_type = self.dst_type
        return functools.partial(_do_blit_iterators, src_type, dst_type, fn)

# This will be generated by Iteratgors at some point,
# with src_type, dst_type, and fn replaced with customized code.
def _do_blit_iterators(src_type, dst_type, fn, s, d):
    d0, d1 = src_type.size_of(s)
    sp = src_type.pointer(s)
    dp = dst_type.pointer(d)
    s_stride_0, s_stride_1 = src_type.strides(s)
    d_stride_0, d_stride_1 = dst_type.strides(d)

    # Loop over index 1.
    if s_stride_0 > s_stride_1:
        s_end = sp + d0 * s_stride_0
    else:
        s_end = sp + d1 * s_stride_1
    s_delta_1 = s_stride_1 - s_stride_0 * d0
    d_delta_1 = d_stride_1 - d_stride_0 * d0
    while (sp < s_end):
        # Loop over index 0.
        sd0_end = sp + s_stride_0 * d0
        while (sp < sd0_end):
            fn(src_type.Pixel(sp), dst_type.Pixel(dp))
            sp += s_stride_0
            dp += d_stride_0

        sp += s_delta_1
        dp += d_delta_1

blitter = Blitter(C_Iterators, [1, 0])
