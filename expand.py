"""Compile loop descriptions file into a Python module
"""

import loops.typer
import loops.python
from loops import astkit
import ast
import re
import ctypes   # For type inlining

def expand(source, path, symbol_table):
    """expand(source: str, path: string, glbs: dict) -> str
    """

    tree, typer_symtab = stage_1(source, path, symbol_table)
    return stage_2(tree), typer_symtab

def stage_1(source, path, symbol_table):
    # Stage One: General template
    symtab = symbol_table.copy()
    module_ast = ast.parse(source, path, 'exec')
    loops.blitkit.inline_decorators(module_ast, symtab)
    return module_ast, typer(module_ast, symtab)

def stage_2(module_ast):
    # Stage Two: Python code
    loops.python.inline_types(module_ast)
    return module_ast

def typer(module, symtab):
    """Add type annotation"""

    visitor = loops.typer.Typer(symtab)
    visitor.visit(module)
    return visitor.globals

# This is what should be generated by expand.expand for
#
#     @loops.blitter(loops.Array2, loops.Surface)
#     def do_blit(s, d):
#         d.pixel = s
#     
# Function globals are: 'ctypes'
#
import ctypes

def do_blit(s: 'loops.Array2', d: 'loops.Surface'):
    # Array dimensions and starting points
    dim_0, dim_1 = s.shape
    s_ptr_0 = s.__array_interface__['data'][0]
    d_ptr_0 = d._pixels_address

    # Pointer increments
    (s_stride_0, s_stride_1) = s.strides
    (d_stride_0, d_stride_1) = (d.get_bytesize(), d.get_pitch())
    s_delta_1 = s_stride_1 - s_stride_0 * dim_0
    d_delta_1 = d_stride_1 - d_stride_0 * dim_0

    # Loop over index 1...
    s_end_1 = s_ptr_0 + s_stride_1 * dim_1
    while s_ptr_0 < s_end_1:
        # Loop over index 0...
        s_end_0 = s_ptr_0 + s_stride_0 * dim_0
        while s_ptr_0 < s_end_0:
            ctypes.c_long.from_address(d_ptr_0).value = int(ctypes.c_long.from_address(s_ptr_0).value)
            s_ptr_0 += s_stride_0
            d_ptr_0 += d_stride_0

        s_ptr_0 += s_delta_1
        d_ptr_0 += d_delta_1
