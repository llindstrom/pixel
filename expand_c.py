"""Compile loop descriptions file into a Python module
"""

import loops.typer
import loops.c
from loops import astkit
import ast
import re
import ctypes   # For type inlining

def expand(source, path, symbol_table):
    """expand(source: str, path: string, glbs: dict) -> str
    """

    tree, typer_symtab = stage_1(source, path, symbol_table)
    return stage_2(tree), typer_symtab

def stage_1(source, path, symbol_table):
    # Stage One: General template
    symtab = symbol_table.copy()
    module_ast = ast.parse(source, path, 'exec')
    loops.blitkit.inline_decorators(module_ast, symtab)
    return module_ast, typer(module_ast, symtab)

def stage_2(module_ast):
    # Stage Two: Python code
    loops.c.inline_types(module_ast)
    return module_ast

def typer(module, symtab):
    """Add type annotation"""

    visitor = loops.typer.Typer(symtab)
    visitor.visit(module)
    return visitor.globals

# This is what should be generated by expand.expand for
#
#     @loops.blitter(loops.Array2, loops.Surface)
#     def do_blit(s, d):
#         d.pixel = s
#     
# Function globals are: 'ctypes'
#
import ctypes

def do_blit(s: 'loops.Array2', d: 'loops.Surface'):
    # Array dimensions and starting points
    t_0 = s[0].shape
    dim_0 = t_0[0]
    dim_1 = t_0[1]
    s_ptr_0 = s[0].pixels
    d_ptr_0 = d[0].buf

    # Pointer increments
    t_1 = s[0].strides
    s_stride_0 = t_1[0]
    s_stride_1 = t_1[1]
    d_stride_0 = d[0].format[0].BytesPerPixel
    d_stride_1 = d[0].pitch
    s_delta_1 = s_stride_1 - s_stride_0 * dim_0
    d_delta_1 = d_stride_1 - d_stride_0 * dim_0

    # Loop over index 1...
    s_end_1 = s_ptr_0 + s_stride_1 * dim_1
    while s_ptr_0 < s_end_1:
        # Loop over index 0...
        s_end_0 = s_ptr_0 + s_stride_0 * dim_0
        while s_ptr_0 < s_end_0:
            CAST('long*')(d_ptr_0)[0] = CAST('long*')(s_ptr_0)[0]
            s_ptr_0 += s_stride_0
            d_ptr_0 += d_stride_0

        s_ptr_0 += s_delta_1
        d_ptr_0 += d_delta_1
